---
title: Git history reset
updated: 2016-05-30 11:42
---

我们使用版本控制的一个目的是能够更好的控制项目的进展，同时在某些时候能够后悔一下，回到之前某个正确的版本中。所以版本回退还是比较重要的，在git中有两种层面的版本回退。一个是对某次的commit的回退，一个是某个file的回退。

下面用reset, revert, checkout这三个命令来完成不同的回退。

## Reset
顾名思义，reset——重置。 我们用这个命令来重置我们的提交历史，或者是我们的文件。
reset一般辅以一些参数`--hard` `--soft` `mixed`.

+ --hard  缓冲区和工作目录都同步到你指定的那次commit中
+ --soft  只是同步版本库的内容，缓冲区和工作目录中的内容不会改变
+ --mixed 默认的选项。工作目录的内容不变，但是缓冲区和版本库都同步到你指定的commit

> git 一般有三个区域，工作区域，缓冲区(暂存区)，版本库。 其中缓冲区就是当你执行了git add xxx 后，修改的文件暂时会放在这个区域里面。当你执行了git commit xxx后，修改会写入到版本库中，形成一个新的提交(commit)。

所以有如下的几种情况：

+ 误提交了本地的修改到版本库

当你在进行本地开发时，不小心将本地未测试通过的内容提交到了版本库中，如果此刻你用`git reset --hard HEAD^` 那么本地开发的内容就会丢失掉。所以此时你可以`git reset HEAD^` 这样版本库和暂存区内的提交被撤销掉了，你可以继续的接着之前的开发继续进行。

+ 放弃当前的所有修改，回到上一个稳定的版本中

这个你需要思考成熟后，在进行操作，一旦你执行了`git reset --hard HEAD^`你当前所有的内容都丢失了，版本库，暂存区以及工作目录中的内容都会变成上一次提交时的内容。不过内，你也不用紧张，你还是有机会反悔的。

+ 撤销刚提交到暂存区的内容

有时你无意间将某一个文件提交到了暂存区，而这个文件你并不打算将其放到下一个版本中，此时你可以使用`git reset HEAD file1` 这将会用当前版本库中内容替换暂存区中的文件，这就达到了将刚提交到暂存区中的文件撤销add的目的。这边的撤销不是代表将文件从暂存区中删除，而只是将文件还原成当前版本库中的版本。

不过这个命令同时还可以将某一个具体的版本中的file放到当前的暂存区中。`git reset HEAD~2 file1`.现在暂存区中的file1便是之前的版本中的了。现在你可以先执行一次commit，形成一个新的版本。

### 后悔一次
刚刚提到了，在你使用了`git reset --hard xxx`后，你就完全的回到你想回退的那个版本去了，这也就意味着你的在这这个版本之后的提交都将丢失，你使用`git log --pretty=oneline` 你会发现当前的head/master都指向了你回退的版本。但是你发现你做错了，你回退的版本不是你想要的版本，你不想回退了。此时还有一个补救方式：

```
git reflog  #查看你之前的每一次命令，找到你想回去的那个版本的版本id
git reset --hard xxx_id  #恢复最开始的场景
```

我一般在进行这样的操作时，总会创建一个branch来备份一下当前的branch。等到操作没有问题后，再将其删除，留有余地。

## Checkout

checkout大多数情况用在检出branch上，你可以很轻松的使用`git checkout branch_name` 检出branch。不过checkout同样可以用在检出版本。

> git中有一个所谓的浮标一样的指针HEAD. 它可以随意的移动，当你切换分支时，他会移动到新的分支上。可以将其理解成指向current版本。

checkout在操作版本的时候就是在操作HEAD.我们的提交历史没有变化，只是将HEAD移动到指定的commit上去，下面的对比图就可以让你看出区别：
![pic1](image/git_checkout1.jpg)
![pic2](image/git_checkout2.jpg)

只是HEAD上下浮动了，不过此时git会提示你现在是游离状态。这一点需要注意。

对于检出文件，可以这样`git checkout commit_id filename`. 这将用指定commit版本中的file替换当前的工作目录中的file。这也达到了对某个文件的回滚。一般对文件操作都是这样来进行的。

## Revert

revert比较特殊一点，他不会修改当前的提交历史，他只会撤销掉你指定的，同时创建一个新的提交。不过这个撤销的同时会有冲突，可以手动解决冲突重新提交。一般使用`git revert commit_id`

revert不能对单个文件进行回滚。所以这一点和上面的两个有所不同。









