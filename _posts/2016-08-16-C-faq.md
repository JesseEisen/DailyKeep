---
title: C Program FAQ
updated: 2016-08-16  16:21
---

##### [compile] How to add and remove Warning flags in gcc

This is a RTFM question, but there ara also some great points need to pay attention. First, when we add the `-Wall` flag. That means it **enables all the warnings**. The specify information you can refer the manual.

if you do not want to enable all the warning flags. You can follow below which refered by gcc manual.

> You can request many specific warnings with options beginning with ‘-W’, for example -Wimplicit to request warnings on implicit declarations. Each of these specific warning options also has a negative form beginning ‘-Wno-’ to turn off warnings; for example, -Wno-implicit. This manual lists only one of the two forms, whichever is not the default.

The reference of this manual online: [Warning Options](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)

##### [compile] Warning: integer constant is too large for 'long' type

When we write a function like `void add(int a, long long b) {...}`. And invoked in this way: `add(0x12,0x123450000)`. Gcc will throw a warning show above. The reason is `long long` can hold the numnber `0x123450000`, but in function invokation, the compiler cannot to recognize that. so we only need to add `LL` to the number.

```
add(0x12, 0x123450000LL);
```

##### [compile] Warning: this decimal constant is unsigned only in ISO C90

这个warning只会在低版本的gcc中出现，因为C90中不支持`long long`选项，所以`-2147483648`这个数超过了long的长度，此时如果是在这个常量后面加上LL标记，则该warning便会被去除。

另一种解决办法是在gcc编译的时候加上`-std=c99`.  该错误在gcc (GCC) 4.1.2 20080704 (Red Hat 4.1.2-52)上未出现。

注： 如果写成如下的两种方式也不会触发warning：
- a = 0x8000000;
- a = -2147483647-1;

##### [compile] Error: enumeration value ‘xxx’ not handled in switch [-Werror=switch]

这个错误的原因是使用的enum值作为switch的检索，如果此时没有对所有的enum的项进行case遍历，则会出现这样的错误。

注：使用枚举类型作switch的一个好处是，如果枚举值比较少，则不需要使用default项的。这个有利于检查。如果项比较多，则需要加上default项。这个错误的解决办法是：加上default项即可。


##### [skills] What does the __builtin_expect do in C

This is a GNU C builtin function. The function definition is :

```c
long __builtin_expect(long exp, long c)
```

The reutnr value is the value of `exp`, which should be an integral expression.The semantics of the built-in are that it is expected that `exp==c`. For example:

```c
if(__builitin_expect(x,0))
	foo();
```

indicates that we do not expect to call `foo`, since we expect x to be zero. Since you are limited to integral expressions for `exp`.

Notice: if the `exp == c` the optimise will get more improve, else the optimise may down.

There are two marcos in linux kernel code:

```c
#define likely(x)  __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x),0)
```

Reference: [GCC Builtins Documentation](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)


##### [skills] How to get term size 

This first way is use `ncurses` to get the size, but you need to install ncurses first. so this is not a primary way to take.

Here is a another way to do that: `ioctl` , take a look

```
#include <stdio.h>
#include <sys/ioctl.h>

int main(void){
	struct winsize ws;
	ioctl(1, TIOCGWINSZ,&ws);

	printf("line: %d\n",ws.ws_row);
	printf("column: %d\n", ws.ws_col);

	return 0;	
}

```

so we can get the size of current term's dimensions
