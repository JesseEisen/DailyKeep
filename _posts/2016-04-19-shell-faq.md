---
title: Shell Script FAQ Hightlight
updated: 2016-04-19  16:21
---

## 1.How to extract the string between two \n in a file

This category questions **we can consider use the `awk` to slove it**. Because it is regularity. we can separate the line by `\n`, and make each part as a record.

```html
<span class="WebRupee">Rs.</span>\n29\n<br/><font style="font-size:smaller">\n3 days\n</font></td>
```

Here we need to parse the `29`,`3 days` ect. We can find that the target is surrounded by `\n`. So we can use `awk` tp solve it.

```bash
awk 'NR%2 == 0' RS='\\\\n' input.txt
```

we separate the line into different record by `\n`. and the target is the on the even record. 

**Another Way**  

Also we can use the `grep` to solve that.Just match the string between `\n`. so we can do:

```bash
$ grep -o '\\n[^\\]*\\n' input.txt
\n29\n
\n3 days\n
```
So we just need to eliminate the `\n` surrounded. There are two ways to make that.

####  1. Use the GNU grep

If you use the GUN grep, we can use the `-P` which use the `perl like RE`. so the command should be 

```bash
grep -oP '(?<=\\n)[^\\<>]*(?=\\n)' input.txt
```

Explain:The `-P` is the make grep to use the `perl`regular expression.`(?<=\\n)` is a look-behind assertion and the `(?=\\n)` is look-ahead assertion.Both of them are the `Lookaround Assertions` in perl.
You can refer the: [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html).


#### 2. Use the `sed` to move that

```bash
grep -o '\\n[^\\]*\\n' input.txt | sed 's/\\n//g'
```

So, It all determined by you to use which way.



## 2.Using -exec to move file after find 

> find . -type f -exec mv -b --suffix=bak ./backup {} +

If we expand this commad, we will find that:

```bash
mv -b --suffix=bak ./backup ./file1 ./file2 ...
```

So that will get wrong, because the `mv` need the last argument must be a `directory`. now is the `file`.
There are two way to solve it .

```bash
find . -type f -exec mv -b --suffix=bak {} ./backup \;  
or
find . -type f -exec mv -b --suffix=bak -t ./backup {} +  #if you use the gnu mv
```

More need to pay attention is mv parameters:

+ `-b or --backup` 
The `--backup=[CONTROL]` set the backup type, The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX. and the `CONTROL` value can be : `none`, `numbered`, `existing`, `simple`.

And the `-b` is same like `--backup`, but it no receive any argument.

+ `--suffix`
override the usual backup suffix

And the backup will work when the destation directory have the same filename as the file you mv, so `mv` will not override that. 


## How to delete file with garbled name

we can use the `ls -i` to find the `inode` info of the file. so we can use the `find` command to find it and delete it. like:

```bash
ls -i
# 394476 xxx*?er?file
find . -inum 394476 -exec rm {} +
```

sometimes we can use the permission number to find them and delete them. like if the file own to the root, so we can use the `find` in this way:

```bash
find ! -name ".*" -maxdepth 1 -type f -perm 0644 -exec rm {} +
```

And may get an error like:

> find: warning: you have specified the -maxdepth option after a non-option argument !, but options are not positional (-maxdepth affects tests specified before it as well as those specified after it).  Please specify options before other arguments.
